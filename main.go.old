package main

import (
  "fmt"
  "log"
  "nogo/utils"
  "os"
  "sort"

  "github.com/BurntSushi/toml"
  "github.com/urfave/cli/v2"
)

type ParseGlobalConfigTemplate struct {
  ConfigPath string `toml:"config_path"`
}

func (p *ParseGlobalConfigTemplate) EncodeTemplate() map[string]interface{} {
  return map[string]interface{}{
    "config_path": p.ConfigPath,
  }
}

func (p *ParseGlobalConfigTemplate) WriteToFile() {
  g_fname := globalConfig.Fname()
  f, err := os.OpenFile(g_fname, os.O_WRONLY, 0777)
  if err != nil {
    log.Fatal(err)
  }
  if err := toml.NewEncoder(f).Encode(p.EncodeTemplate()); err != nil {
    log.Fatal(err)
  }
  if err := f.Close(); err != nil {
    log.Fatal(err)
  }
}

[>
  Checks if global configuration file exists:
    [exists] -> parses file, returns ParseGlobalConfigTemplate
    [not exists] -> prompts to create
      [create] -> creates file
      [not create] -> uses default local config

  returns parsed global config file and bool if default local_config is used
  @returns ParseGlobalConfigTemplate, bool
*/
func createOrReadGlobalConfig() (ParseGlobalConfigTemplate, bool) {
  var parsed_g_config ParseGlobalConfigTemplate
  //fname := globalConfig["config_path"] + globalConfig["config_file"]
  g_fname := globalConfig.Fname()
  if _, exists := os.Stat(g_fname); os.IsNotExist(exists) {
    create := utils.PromptBool(fmt.Sprintf("[ nogo WARNING ]: Global configuration file %s does not exist\n[ nogo WARNING ]: Creating?", g_fname), true)
    if create {
      utils.CreateFile(g_fname)
    } else {
      utils.Warn("Global configuration file not created; global defaults will not be saved")
      utils.Hint(fmt.Sprintf("You can still use the tool if you (1) provide a configuration file via command line arguments\n... or (2) use a file in the default directory: %s\n\n    (1): SOME EXAMPLE HERE ...\n    (2): SOME OTHER EXAMPLE HERE", localConfig.Fname()))
      return parsed_g_config, true
    }
  }
  toml.DecodeFile(g_fname, &parsed_g_config)
  return parsed_g_config, false
}

func createLocalConfig() {
}

//func main() {
  //// g, _ := createOrReadGlobalConfig()
  //var g ParseGlobalConfigTemplate
  //toml.DecodeFile("/Users/hayk/.tmp/nogo/global.toml", &g)
  //fmt.Println(g)
//}

func main() {
  log.SetPrefix("[ nogo ERROR ]: ")
  log.SetFlags(0)
  app := &cli.App{
    Name:  "nogo",
    Usage: "do awesome stuff with notion from cli",
    Action: func(c *cli.Context) error {
      //if _, exists := os.Stat(); os.IsNotExist(exists) {
      //// config file does not exist
      //create := prompt.nogoPrompt(fmt.Sprintf("File %s does not exist.\nCreate?", fname), nil, "y", "n")
      //if create == "y" {
      //f, err := createFile()
      //if err != nil {
      //log.Fatal(err)
      //}
      //defer f.Close()
      //if _, exists := os.Stat(fname); os.IsNotExist(exists) {
      //log.Fatal("Failed to create file")
      //}
      //} else {
      //log.Fatalf("File %s does not exist and was not created.", fname)
      //}
      //} else {
      //// config file already exists
      //}
      return nil
    },
    //Flags: []cli.Flag{
    //&cli.StringFlag{
    //Name:    "lang",
    //Aliases: []string{"l"},
    //Value:   "english",
    //Usage:   "Language for the greeting",
    //},
    //&cli.StringFlag{
    //Name:    "config",
    //Aliases: []string{"c"},
    //Usage:   "Load configuration from `FILE`",
    //},
    //},
    Commands: []*cli.Command{
      {
        Name:    "configure",
        Aliases: []string{"c"},
        Usage:   "(⚙) configure nogo using prompt",
        Action: func(c *cli.Context) error {
          fmt.Println("- - - - - ( nogo configure wizard ⚙ ) - - - - -")
          parsed_g_config, use_default := createOrReadGlobalConfig()
          if parsed_g_config.ConfigPath == "" || use_default {
            parsed_g_config.ConfigPath = localConfig.Fname()
            if !use_default {
              parsed_g_config.WriteToFile()
              utils.Message("writing: " + parsed_g_config.ConfigPath)
            }
          }
          // !TODO:
          if !use_default {
            utils.Message("Configuration file found at: " + parsed_g_config.ConfigPath)
          }
          // if exists -> read localConfig and ask if needs to change
          // API key
          return nil
        },
      },
      //{
      //Name:    "add",
      //Aliases: []string{"a"},
      //Usage:   "add a task to the list",
      //Action:  func(c *cli.Context) error {
      //return nil
      //},
      //},
    },
  }

  sort.Sort(cli.FlagsByName(app.Flags))
  sort.Sort(cli.CommandsByName(app.Commands))

  err := app.Run(os.Args)
  if err != nil {
    log.Fatal(err)
    //panic(err)
  }
}
